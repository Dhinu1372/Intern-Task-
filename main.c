/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2026 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/********************************************************************
 * STM32F407G â€“ Bare Metal Example (REGISTER LEVEL, NO HAL)
 *
 * FUNCTION:
 * TIM2 @ 100Hz overflow triggers ADC1 (PA0)
 * ADC1 result transferred to RAM using DMA2 Stream0
 * ADC values sent via USART2 (PA2) to PC terminal
 *
 * NOTE:
 * - Direct register address access only
 * - Internal HSI = 16 MHz assumed
 ********************************************************************/

#include <stdint.h>

/* ================= BASE ADDRESSES ================= */
#define PERIPH_BASE     0x40000000UL
#define AHB1_BASE       (PERIPH_BASE + 0x20000UL)
#define APB1_BASE       (PERIPH_BASE + 0x00000UL)
#define APB2_BASE       (PERIPH_BASE + 0x10000UL)

/* ================= RCC ================= */
#define RCC_BASE        (AHB1_BASE + 0x3800UL)
#define RCC_AHB1ENR     (*(volatile uint32_t *)(RCC_BASE + 0x30))
#define RCC_APB1ENR     (*(volatile uint32_t *)(RCC_BASE + 0x40))
#define RCC_APB2ENR     (*(volatile uint32_t *)(RCC_BASE + 0x44))

/* ================= GPIOA ================= */
#define GPIOA_BASE      (AHB1_BASE + 0x0000UL)
#define GPIOA_MODER     (*(volatile uint32_t *)(GPIOA_BASE + 0x00))
#define GPIOA_AFRL      (*(volatile uint32_t *)(GPIOA_BASE + 0x20))

/* ================= USART2 ================= */
#define USART2_BASE     (APB1_BASE + 0x4400UL)
#define USART2_SR       (*(volatile uint32_t *)(USART2_BASE + 0x00))
#define USART2_DR       (*(volatile uint32_t *)(USART2_BASE + 0x04))
#define USART2_BRR      (*(volatile uint32_t *)(USART2_BASE + 0x08))
#define USART2_CR1      (*(volatile uint32_t *)(USART2_BASE + 0x0C))

/* ================= TIM2 ================= */
#define TIM2_BASE       (APB1_BASE + 0x0000UL)
#define TIM2_CR1        (*(volatile uint32_t *)(TIM2_BASE + 0x00))
#define TIM2_CR2        (*(volatile uint32_t *)(TIM2_BASE + 0x04))
#define TIM2_PSC        (*(volatile uint32_t *)(TIM2_BASE + 0x28))
#define TIM2_ARR        (*(volatile uint32_t *)(TIM2_BASE + 0x2C))

/* ================= ADC1 ================= */
#define ADC1_BASE       (APB2_BASE + 0x2000UL)
#define ADC1_CR1        (*(volatile uint32_t *)(ADC1_BASE + 0x04))
#define ADC1_CR2        (*(volatile uint32_t *)(ADC1_BASE + 0x08))
#define ADC1_SMPR2      (*(volatile uint32_t *)(ADC1_BASE + 0x10))
#define ADC1_SQR1       (*(volatile uint32_t *)(ADC1_BASE + 0x2C))
#define ADC1_SQR3       (*(volatile uint32_t *)(ADC1_BASE + 0x34))
#define ADC1_DR         (*(volatile uint32_t *)(ADC1_BASE + 0x4C))

/* ================= DMA2 Stream0 ================= */
#define DMA2_BASE       (AHB1_BASE + 0x6400UL)
#define DMA2_LIFCR      (*(volatile uint32_t *)(DMA2_BASE + 0x08))
#define DMA2_S0CR       (*(volatile uint32_t *)(DMA2_BASE + 0x10))
#define DMA2_S0NDTR     (*(volatile uint32_t *)(DMA2_BASE + 0x14))
#define DMA2_S0PAR      (*(volatile uint32_t *)(DMA2_BASE + 0x18))
#define DMA2_S0M0AR     (*(volatile uint32_t *)(DMA2_BASE + 0x1C))

/* ================= BUFFER ================= */
volatile uint16_t adc_buffer;

/* ================= UART FUNCTIONS ================= */
void uart_send_char(char c)
{
    while (!(USART2_SR & (1 << 7)));
    USART2_DR = c;
}

void uart_send_string(const char *s)
{
    while (*s)
        uart_send_char(*s++);
}

void uart_send_dec(uint16_t v)
{
    char buf[6];
    int i = 0;

    if (v == 0)
    {
        uart_send_char('0');
        return;
    }

    while (v)
    {
        buf[i++] = (v % 10) + '0';
        v /= 10;
    }

    while (i--)
        uart_send_char(buf[i]);
}

/* ================= MAIN ================= */
int main(void)
{
    /* CLOCK ENABLE */
    RCC_AHB1ENR |= (1 << 0);     // GPIOA
    RCC_AHB1ENR |= (1 << 22);    // DMA2
    RCC_APB1ENR |= (1 << 0);     // TIM2
    RCC_APB1ENR |= (1 << 17);    // USART2
    RCC_APB2ENR |= (1 << 8);     // ADC1

    /* GPIO CONFIG */
    GPIOA_MODER |= (3 << 0);     // PA0 analog
    GPIOA_MODER &= ~(3 << 4);
    GPIOA_MODER |=  (2 << 4);    // PA2 AF
    GPIOA_AFRL  |=  (7 << 8);    // AF7 USART2

    /* USART2 INIT */
    USART2_BRR = 0x8B;           // 115200 @ 16 MHz
    USART2_CR1 |= (1 << 3);      // TE
    USART2_CR1 |= (1 << 13);     // UE

    /* TIM2 TRGO @ 100Hz */
    TIM2_PSC = 15999;
    TIM2_ARR = 9;
    TIM2_CR2 |= (2 << 4);        // TRGO = Update
    TIM2_CR1 |= 1;               // Enable timer

    /* DMA CONFIG */
    DMA2_S0CR &= ~1;
    while (DMA2_S0CR & 1);

    DMA2_LIFCR = 0x3D;
    DMA2_S0PAR  = (uint32_t)&ADC1_DR;
    DMA2_S0M0AR = (uint32_t)&adc_buffer;
    DMA2_S0NDTR = 1;

    DMA2_S0CR |= (1 << 8);       // Circular
    DMA2_S0CR |= (1 << 10);      // MINC
    DMA2_S0CR |= (1 << 11);      // PSIZE 16-bit
    DMA2_S0CR |= (1 << 13);      // MSIZE 16-bit
    DMA2_S0CR |= 1;              // Enable DMA

    /* ADC CONFIG */
    ADC1_SMPR2 |= (7 << 0);      // Channel 0 sample
    ADC1_SQR1 = 0;
    ADC1_SQR3 = 0;

    ADC1_CR2 |= (1 << 8);        // DMA
    ADC1_CR2 |= (1 << 9);        // DDS
    ADC1_CR2 |= (6 << 24);       // TIM2 TRGO
    ADC1_CR2 |= (1 << 28);       // Rising edge
    ADC1_CR2 |= 1;               // ADC ON

    for (volatile int i = 0; i < 10000; i++);


    while (1)
    {
        uart_send_dec(adc_buffer);
        uart_send_string("\r\n");
        for (volatile int d = 0; d < 200000; d++);
    }
}
